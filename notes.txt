//github.com/zsoltkiss/Java_Basics
//Modified from DBSYS
//Modified with GitHub DeskTop

OOP:
- Abstraction
- Inheritance
- Polymorphism
- Encapsulation
("A PIE")

class MyClass{
    [...adattagok...]

    //Constructor, ha nem a default:
    public MyClass(){

    }

    //Nem példányosítható class esetén:
    private MyClass(){

    }
    //Pl.: MyClass.getInstance(); - ez adhat vissza egy példányt, a private MyClass hívásával.
    //Ebben esetben static metódusokat lehet hívni.

    finalize() - Az elárvult példány megszüntetése előtt fut le. Erőforrások felszabadítását végezheti el pl.
        Korrekt módon megírt class esetén nincs rá szükség.
}

Access modifiers:
- private   : classon belüli elérhetőség.
- public    : teljes elérhetőség.
- protected : a leszármazottjai érhetik el, csomagtól függetlenül; valamint csomagon belül elérhető.
- (default) : package-en belüli elérhetőség.

Java Bean névkonvenció:
CamelCase getterek és setterek. A get/set után a változónevek is nagybetűvel kezdődnek.
Boolean változó gettere nem "get" hanem "is" kezdetű.
A setter és a getter egyfeladatú; mást NE tegyél bele, mint ami belevaló.
A side effect kerülendő. Vagy inkább tilos.
Az értékvalidáció nem side effect. ("guard effect")

Deklarált típus: pl.: Lehet az ősosztály
Futásidejű típus: A deklarált típusú változó leszármazott típusú értéket kap.
Futásidejű típus metódusai csak castolással hívhatók meg.

Final Class: Nem leszármaztatható osztály.
Abstract class: Nem példányosítható osztály. Lehetnek, sőt jellemzően vannak abstract metódusai is.
Az abstract metódusnak nincs blokkja!
Az abstract class leszármazottjának vagy implementálnia kell az abstract metódust, vagy szintén deklarálnia kell
abstractként.

Interface:
- névkonvenció: "...able {}", esetleg "I... {}"
- abstract metódus, de nem utasításokat tarttalmaz, hanem csakis szignatúrákat; természetesen csakis publikusakat.
- pl: Class Circle extends Shape implements Drawable, Colorable, Runable { ... }
- Külön .java állományokban helyezzük el őket. Nem classon belüli rész.
- Interface lehet üres is: Marker interface. Azonos alakúságot biztosítanak vele.
- Az interface mögött cserélhető az implementáció! Pl:

IS-A : Circle is-a Shape: Class Circle extends Shape;
HAS-A: Composition: Circle has-a Color: Van Color adattagja;

Scope: "fókusz"; láthatósági kör.
Scenario: "(színházi) szín"; adott eseménysorozat.

Design Pattern = tervezési minta: Jól bevált programozási módszer. PL:
- Singleton
- factory
- decorator
- observer

Collections
- primitív adattípusokat nem lehet beletenni. Illetve de, csak mégsem: AutoBoxing és AutoUnboxing;
- Az elemek konkrét típusa bármi lehet, különböző is; mivel mind Object;
- Három fő típusuk van:
    - listák:
        (ordered list / managed list)
    - setek (halmazok): Csak duplikálatlan elemek lehetnek benne. Típus is számít! (nem "==" hanem "===" szerint)
    - map-ek (kulcs-érték párok)
- Az interface mögött cserélhető az implementáció! Pl:
        List myNumbers = new ArrayList(); //ArrayList implements List;
        List myNumbers = new LinkedList();//LinkedList implements List;
        Set myPersons = new HashSet();   //
        Map myConfigs = new HashMap();    //A kulcsoknak egyedieknek kell lennie. A konkrét típusuk lehet más, mivel mind Object.
            //De erre is van lehetőség, pl: Map<String,Integer>

- Saját objektumainkban szükséges, ha kollekciókban akarjuk használni:
    - toString() //Csak ajánlott
    - equals( Object o)
    - int hashCode()
    - compareTo( Object o) [A java.lang.Comparable interface-ből] ;
        result:
            0: egyenlőek; vagy a típus nem ugyanaz.
            1: this > other
            -1: this < other

- "Gang of Four":Design Patterns c. könyv (tervezési minták, nyelvfüggetlen módon)
- "Pattern favor":"Minta-láz" : Patternek túlzott használata.

Rekurzió:
- Rekurzív metódusnak legyen menekülőútja.
